{"ast":null,"code":"import { PieceType, TeamType, samePosition } from \"../Constants\";\nexport default class Referee {\n  tileIsOccupied(position, boardState) {\n    const piece = boardState.find(p => samePosition(p.position, position));\n    return piece ? true : false;\n  }\n  tileIsOccupiedByOpponent(position, boardState, team) {\n    const piece = boardState.find(p => samePosition(p.position, position) && p.team !== team);\n    return piece ? true : false;\n  }\n  isEnPassantMove(initialPosition, desiredPosition, type, team, boardState) {\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n    if (type === PieceType.PAWN) {\n      if (desiredPosition.y - initialPosition.y === pawnDirection && (desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1)) {\n        const piece = boardState.find(p => p.position.x === desiredPosition.x && p.position.y === desiredPosition.y - pawnDirection && p.enPassant);\n        return piece ? true : false;\n      }\n    }\n    return false;\n  }\n  isValidMove(initialPosition, desiredPosition, type, team, boardState) {\n    console.log(`referee checking.. piece: ${type}`);\n    //movement\n    if (type === PieceType.PAWN) {\n      const specialRow = team === TeamType.OUR ? 1 : 6;\n      const pawnDirection = team === TeamType.OUR ? 1 : -1;\n      if (initialPosition.x === desiredPosition.x && initialPosition.y === specialRow && desiredPosition.y - initialPosition.y === 2 * pawnDirection) {\n        if (!this.tileIsOccupied(desiredPosition, boardState) && !this.tileIsOccupied({\n          x: desiredPosition.x,\n          y: desiredPosition.y - pawnDirection\n        }, boardState)) {\n          return true;\n        }\n      } else if (initialPosition.x === desiredPosition.x && desiredPosition.y - initialPosition.y === pawnDirection) {\n        return !this.tileIsOccupied(desiredPosition, boardState);\n      }\n      //attack\n      else if (desiredPosition.y - initialPosition.y === pawnDirection && (desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1)) {\n        return this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n      }\n    } else if (type === PieceType.KNIGHT) {\n      // moving mechanics\n      // 8 different tiles possible\n\n      const knightX = [1, 2, 2, 1, -1, -2, -2, -1];\n      const knightY = [2, 1, -1, -2, -2, -1, 1, 2];\n      for (let i = 0; i < 8; i++) {\n        if (desiredPosition.x - initialPosition.x === knightX[i] && desiredPosition.y - initialPosition.y === knightY[i]) {\n          return !this.tileIsOccupied(desiredPosition, boardState) || this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n        }\n      }\n    } else if (type === PieceType.BISHOP) {\n      const dx = desiredPosition.x - initialPosition.x; // difference in X axis\n      const dy = desiredPosition.y - initialPosition.y; // difference in Y axis\n\n      // diagonal movement implies that difference between axis should be equal\n      if (Math.abs(dx) === Math.abs(dy)) {\n        const stepX = dx > 0 ? 1 : -1; // direction of X axis: 1 or -1\n        const stepY = dy > 0 ? 1 : -1; // direction of Y axis: 1 or -1\n\n        // iterate all positions between actual position and desired position (dx or dy)\n        for (let i = 1; i < Math.abs(dx); i++) {\n          // change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\n          const passedPosition = {\n            x: initialPosition.x + i * stepX,\n            y: initialPosition.y + i * stepY\n          };\n\n          // if any intermediate tile is occupied, then is invalid\n          if (this.tileIsOccupied(passedPosition, boardState)) {\n            return false;\n          }\n        }\n\n        // return true (if is not occupied by our team) or (is ocuppied by opponent)\n        return !this.tileIsOccupied(desiredPosition, boardState) || this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n      }\n    } else if (type === PieceType.ROOK) {\n      const dx = desiredPosition.x - initialPosition.x; // difference in X axis\n      const dy = desiredPosition.y - initialPosition.y; // difference in Y axis\n\n      // vertical movement\n      if (dx === 0) {\n        const stepY = dy > 0 ? 1 : -1; // direction of Y axis: 1 or -1\n\n        // iterate all positions between actual position and desired position dy\n        for (let i = 1; i < Math.abs(dy); i++) {\n          // change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\n          const passedPosition = {\n            x: initialPosition.x,\n            y: initialPosition.y + i * stepY\n          };\n\n          // if any intermediate tile is occupied, then is invalid\n          if (this.tileIsOccupied(passedPosition, boardState)) {\n            return false;\n          }\n        }\n      }\n\n      // horizontal movement\n      if (dy === 0) {\n        const stepX = dx > 0 ? 1 : -1; // direction of X axis: 1 or -1\n\n        // iterate all positions between actual position and desired position (dx or dy)\n        for (let i = 1; i < Math.abs(dx); i++) {\n          // change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\n          const passedPosition = {\n            x: initialPosition.x + i * stepX,\n            y: initialPosition.y\n          };\n\n          // if any intermediate tile is occupied, then is invalid\n          if (this.tileIsOccupied(passedPosition, boardState)) {\n            return false;\n          }\n        }\n      }\n      return !this.tileIsOccupied(desiredPosition, boardState) || this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n    }\n    return false;\n  }\n}","map":{"version":3,"names":["PieceType","TeamType","samePosition","Referee","tileIsOccupied","position","boardState","piece","find","p","tileIsOccupiedByOpponent","team","isEnPassantMove","initialPosition","desiredPosition","type","pawnDirection","OUR","PAWN","y","x","enPassant","isValidMove","console","log","specialRow","KNIGHT","knightX","knightY","i","BISHOP","dx","dy","Math","abs","stepX","stepY","passedPosition","ROOK"],"sources":["/home/Outer/Documents/chess-react/src/referee/Referee.ts"],"sourcesContent":["import { PieceType, TeamType, Piece, Position, samePosition} from \"../Constants\";\n\n\nexport default class Referee{\n    tileIsOccupied(position:Position, boardState: Piece[]):boolean{\n        const piece = boardState.find((p) => samePosition(p.position,position));\n        return piece?true:false;\n    }\n\n    tileIsOccupiedByOpponent(position:Position, boardState:Piece[], team:TeamType):boolean{\n        const piece = boardState.find((p)=>samePosition(p.position, position) && p.team!==team);\n        return piece?true:false;\n    }\n\n    isEnPassantMove(initialPosition: Position, desiredPosition:Position, type:PieceType, team:TeamType, boardState:Piece[]):boolean{\n        const pawnDirection = (team === TeamType.OUR)? 1:-1;\n\n        if(type===PieceType.PAWN){\n            if(desiredPosition.y-initialPosition.y===pawnDirection && ((desiredPosition.x-initialPosition.x===-1) || (desiredPosition.x-initialPosition.x===1))){\n                const piece = boardState.find((p)=> p.position.x===desiredPosition.x && (p.position.y===desiredPosition.y - pawnDirection && p.enPassant));\n\n                return piece?true:false;\n            }\n        }\n        return false;\n    }\n\n    isValidMove(initialPosition:Position, desiredPosition: Position, type:PieceType, team:TeamType, boardState:Piece[]){\n        console.log(`referee checking.. piece: ${type}`);\n        //movement\n        if(type === PieceType.PAWN){\n            const specialRow = (team === TeamType.OUR)?1:6;\n            const pawnDirection = (team === TeamType.OUR)? 1:-1;\n\n            if(initialPosition.x===desiredPosition.x && initialPosition.y===specialRow && desiredPosition.y-initialPosition.y===2*pawnDirection){\n                if(!this.tileIsOccupied(desiredPosition,boardState) && !this.tileIsOccupied({x: desiredPosition.x, y:desiredPosition.y-pawnDirection}, boardState)){\n                    return true;\n                }\n            }else if(initialPosition.x===desiredPosition.x && desiredPosition.y-initialPosition.y===pawnDirection){\n                    return !this.tileIsOccupied(desiredPosition,boardState)\n            }\n            //attack\n            else if(desiredPosition.y-initialPosition.y===pawnDirection && ((desiredPosition.x-initialPosition.x===-1) || (desiredPosition.x-initialPosition.x===1))){\n                return this.tileIsOccupiedByOpponent(desiredPosition,boardState,team);\n            }\n        } else if(type === PieceType.KNIGHT){\n            // moving mechanics\n            // 8 different tiles possible\n\n            const knightX = [1,2,2,1,-1,-2,-2,-1];\n            const knightY = [2,1,-1,-2,-2,-1,1,2];\n\n            for(let i=0;i<8;i++){\n                if((desiredPosition.x - initialPosition.x === knightX[i]) && (desiredPosition.y - initialPosition.y === knightY[i])){\n                    return (!this.tileIsOccupied(desiredPosition,boardState) || this.tileIsOccupiedByOpponent(desiredPosition,boardState, team))\n                } \n            }\n        } else if (type === PieceType.BISHOP) {\n            const dx = desiredPosition.x - initialPosition.x; // difference in X axis\n            const dy = desiredPosition.y - initialPosition.y; // difference in Y axis\n\n            // diagonal movement implies that difference between axis should be equal\n            if (Math.abs(dx) === Math.abs(dy)) {\n                const stepX = dx > 0 ? 1 : -1; // direction of X axis: 1 or -1\n                const stepY = dy > 0 ? 1 : -1; // direction of Y axis: 1 or -1\n\n                // iterate all positions between actual position and desired position (dx or dy)\n                for (let i = 1; i < Math.abs(dx); i++) {\n                    // change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\n                    const passedPosition: Position = {\n                        x: initialPosition.x + i * stepX,\n                        y: initialPosition.y + i * stepY,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (this.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n\n                // return true (if is not occupied by our team) or (is ocuppied by opponent)\n                return !this.tileIsOccupied(desiredPosition, boardState) ||\n                    this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n            }\n        } else if (type === PieceType.ROOK) {\n            const dx = desiredPosition.x - initialPosition.x; // difference in X axis\n            const dy = desiredPosition.y - initialPosition.y; // difference in Y axis\n\n            // vertical movement\n            if (dx === 0){\n                const stepY = dy > 0 ? 1 : -1; // direction of Y axis: 1 or -1\n\n                // iterate all positions between actual position and desired position dy\n                for (let i = 1; i < Math.abs(dy); i++) {\n                    // change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\n                    const passedPosition: Position = {\n                        x: initialPosition.x,\n                        y: initialPosition.y + i * stepY,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (this.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n            }\n\n            // horizontal movement\n            if (dy === 0){\n                const stepX = dx > 0 ? 1 : -1; // direction of X axis: 1 or -1\n\n                // iterate all positions between actual position and desired position (dx or dy)\n                for (let i = 1; i < Math.abs(dx); i++) {\n                    // change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\n                    const passedPosition: Position = {\n                        x: initialPosition.x + i * stepX,\n                        y: initialPosition.y,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (this.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n            }\n\n                return !this.tileIsOccupied(desiredPosition, boardState) ||\n                    this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n\n        }\n\n        return false;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
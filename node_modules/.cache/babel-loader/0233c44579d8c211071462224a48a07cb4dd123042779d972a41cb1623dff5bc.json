{"ast":null,"code":"import { PieceType, TeamType } from \"../Constants\";\nexport default class Referee {\n  tileIsOccupied(x, y, boardState) {\n    const piece = boardState.find(p => p.position.x === x && p.position.y === y);\n    return piece != undefined;\n  }\n  tileIsOccupiedByOpponent(x, y, boardState, team) {\n    const piece = boardState.find(p => p.position.x === x && p.position.y === y && p.team !== team);\n    return piece ? true : false;\n  }\n  isEnPassantMove(initialPosition, desiredPosition, type, team, boardState) {\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n    if (type === PieceType.PAWN) {\n      if (desiredPosition.y - initialPosition.y === pawnDirection && (desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1)) {\n        const piece = boardState.find(p => p.position.x === desiredPosition.x && p.position.y === desiredPosition.y - pawnDirection && p.enPassant);\n        return piece ? true : false;\n      }\n    }\n    return false;\n  }\n  isValidMove(initialPosition, desiredPosition, type, team, boardState) {\n    console.log(`referee checking.. piece: ${type}`);\n    //movement\n    if (type === PieceType.PAWN) {\n      const specialRow = team === TeamType.OUR ? 1 : 6;\n      const pawnDirection = team === TeamType.OUR ? 1 : -1;\n      if (initialPosition.x === desiredPosition.x && initialPosition.y === specialRow && desiredPosition.y - initialPosition.y === 2 * pawnDirection) {\n        if (!this.tileIsOccupied(desiredPosition.x, desiredPosition.y, boardState) && !this.tileIsOccupied(desiredPosition.x, desiredPosition.y - pawnDirection, boardState)) {\n          return true;\n        }\n      } else if (initialPosition.x === desiredPosition.x && desiredPosition.y - initialPosition.y === pawnDirection) {\n        if (!this.tileIsOccupied(desiredPosition.x, desiredPosition.y, boardState)) {\n          return true;\n        }\n      }\n      //attack\n      else if (desiredPosition.y - initialPosition.y === pawnDirection && (desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1)) {\n        if (this.tileIsOccupiedByOpponent(desiredPosition.x, desiredPosition.y, boardState, team)) {\n          return true;\n        }\n      }\n    } else if (type === PieceType.KNIGHT) {\n      // moving mechanics\n      // 8 different tiles possible\n\n      const knightX = [1, 2, 2, 1, -1, -2, -2, -1];\n      const knightY = [2, 1, -1, -2, -2, -1, 1, 2];\n      for (let i = 0; i <= 8; i++) {\n        if (desiredPosition.x - initialPosition.x === knightX[i] && desiredPosition.y - initialPosition.y === knightY[i]) {\n          console.log(\"sisisisi\");\n        }\n      }\n    }\n    return false;\n  }\n}","map":{"version":3,"names":["PieceType","TeamType","Referee","tileIsOccupied","x","y","boardState","piece","find","p","position","undefined","tileIsOccupiedByOpponent","team","isEnPassantMove","initialPosition","desiredPosition","type","pawnDirection","OUR","PAWN","enPassant","isValidMove","console","log","specialRow","KNIGHT","knightX","knightY","i"],"sources":["/home/Outer/Documents/chess-app/src/referee/Referee.ts"],"sourcesContent":["import { PieceType, TeamType, Piece, Position} from \"../Constants\";\n\n\nexport default class Referee{\n    tileIsOccupied(x: number,y: number, boardState: Piece[]):boolean{\n        const piece = boardState.find(p=> p.position.x===x && p.position.y===y)\n        return piece!=undefined;\n    }\n\n    tileIsOccupiedByOpponent(x:number, y:number, boardState:Piece[], team:TeamType):boolean{\n        const piece = boardState.find((p)=>p.position.x===x && p.position.y===y && p.team!==team);\n        return piece?true:false;\n    }\n\n    isEnPassantMove(initialPosition: Position, desiredPosition:Position, type:PieceType, team:TeamType, boardState:Piece[]):boolean{\n        const pawnDirection = (team === TeamType.OUR)? 1:-1;\n\n        if(type===PieceType.PAWN){\n            if(desiredPosition.y-initialPosition.y===pawnDirection && ((desiredPosition.x-initialPosition.x===-1) || (desiredPosition.x-initialPosition.x===1))){\n                const piece = boardState.find((p)=> p.position.x===desiredPosition.x && (p.position.y===desiredPosition.y - pawnDirection && p.enPassant));\n\n                return piece?true:false;\n            }\n        }\n        return false;\n    }\n\n    isValidMove(initialPosition:Position, desiredPosition: Position, type:PieceType, team:TeamType, boardState:Piece[]){\n        console.log(`referee checking.. piece: ${type}`);\n        //movement\n        if(type === PieceType.PAWN){\n            const specialRow = (team === TeamType.OUR)?1:6;\n            const pawnDirection = (team === TeamType.OUR)? 1:-1;\n\n            if(initialPosition.x===desiredPosition.x && initialPosition.y===specialRow && desiredPosition.y-initialPosition.y===2*pawnDirection){\n                if(!this.tileIsOccupied(desiredPosition.x,desiredPosition.y,boardState) && !this.tileIsOccupied(desiredPosition.x,desiredPosition.y - pawnDirection, boardState)){\n                    return true;\n                }\n            }else if(initialPosition.x===desiredPosition.x && desiredPosition.y-initialPosition.y===pawnDirection){\n                    if(!this.tileIsOccupied(desiredPosition.x,desiredPosition.y,boardState)){\n                        return true;\n                    }\n            }\n            //attack\n            else if(desiredPosition.y-initialPosition.y===pawnDirection && ((desiredPosition.x-initialPosition.x===-1) || (desiredPosition.x-initialPosition.x===1))){\n                if(this.tileIsOccupiedByOpponent(desiredPosition.x,desiredPosition.y,boardState,team)){\n                    return true;\n                }\n            }\n        } else if(type === PieceType.KNIGHT){\n            // moving mechanics\n            // 8 different tiles possible\n\n            const knightX = [1,2,2,1,-1,-2,-2,-1];\n            const knightY = [2,1,-1,-2,-2,-1,1,2];\n\n            for(let i=0;i<=8;i++){\n                if((desiredPosition.x - initialPosition.x === knightX[i]) && (desiredPosition.y - initialPosition.y === knightY[i])){\n                    console.log(\"sisisisi\");\n                }\n            }\n        }\n\n        return false;\n    }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { PieceType, TeamType, samePosition } from \"../Constants\";\nexport default class Referee {\n  tileIsOccupied(position, boardState) {\n    const piece = boardState.find(p => samePosition(p.position, position));\n    return piece ? true : false;\n  }\n  tileIsOccupiedByOpponent(position, boardState, team) {\n    const piece = boardState.find(p => samePosition(p.position, position) && p.team !== team);\n    return piece ? true : false;\n  }\n  isEnPassantMove(initialPosition, desiredPosition, type, team, boardState) {\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n    if (type === PieceType.PAWN) {\n      if (desiredPosition.y - initialPosition.y === pawnDirection && (desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1)) {\n        const piece = boardState.find(p => p.position.x === desiredPosition.x && p.position.y === desiredPosition.y - pawnDirection && p.enPassant);\n        return piece ? true : false;\n      }\n    }\n    return false;\n  }\n  pawnMove(initialPosition, desiredPosition, team, dx, dy, boardState) {\n    const specialRow = team === TeamType.OUR ? 1 : 6;\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n    if (initialPosition.x === desiredPosition.x && initialPosition.y === specialRow && dy === 2 * pawnDirection) {\n      if (!this.tileIsOccupied(desiredPosition, boardState) && !this.tileIsOccupied({\n        x: desiredPosition.x,\n        y: desiredPosition.y - pawnDirection\n      }, boardState)) {\n        return true;\n      }\n    } else if (initialPosition.x === desiredPosition.x && dy === pawnDirection) {\n      return !this.tileIsOccupied(desiredPosition, boardState);\n    }\n    //attack\n    else if (dy === pawnDirection && (dx === -1 || dx === 1)) {\n      return this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n    }\n    return false;\n  }\n  knightMove(initialPosition, desiredPosition, team, dx, dy, boardState) {\n    // moving mechanics\n    // 8 different tiles possible\n\n    const knightX = [1, 2, 2, 1, -1, -2, -2, -1];\n    const knightY = [2, 1, -1, -2, -2, -1, 1, 2];\n    for (let i = 0; i < 8; i++) {\n      if (desiredPosition.x - initialPosition.x === knightX[i] && desiredPosition.y - initialPosition.y === knightY[i]) {\n        return !this.tileIsOccupied(desiredPosition, boardState) || this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n      }\n    }\n    return false;\n  }\n  isValidMove(initialPosition, desiredPosition, type, team, boardState) {\n    console.log(`referee checking.. piece: ${type}`);\n    //movement\n    const dx = desiredPosition.x - initialPosition.x; // difference in X axis\n    const dy = desiredPosition.y - initialPosition.y; // difference in Y axis\n    const stepX = dx > 0 ? 1 : -1; // direction of X axis: 1 or -1\n    const stepY = dy > 0 ? 1 : -1; // direction of Y axis: 1 or -1\n\n    if (type === PieceType.PAWN) {\n      return this.pawnMove(initialPosition, desiredPosition, team, dx, dy, boardState);\n    } else if (type === PieceType.KNIGHT) {\n      return this.knightMove(initialPosition, desiredPosition, team, dx, dy, boardState);\n    } else if (type === PieceType.BISHOP) {\n      // diagonal movement implies that difference between axis should be equal\n      if (Math.abs(dx) === Math.abs(dy)) {\n        // iterate all positions between actual position and desired position (dx or dy)\n        for (let i = 1; i < Math.abs(dx); i++) {\n          // change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\n          const passedPosition = {\n            x: initialPosition.x + i * stepX,\n            y: initialPosition.y + i * stepY\n          };\n\n          // if any intermediate tile is occupied, then is invalid\n          if (this.tileIsOccupied(passedPosition, boardState)) {\n            return false;\n          }\n        }\n\n        // return true (if is not occupied by our team) or (is ocuppied by opponent)\n        return !this.tileIsOccupied(desiredPosition, boardState) || this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n      }\n    } else if (type === PieceType.ROOK) {\n      // vertical movement\n      if (dx === 0) {\n        // iterate all positions between actual position and desired position dy\n        for (let i = 1; i < Math.abs(dy); i++) {\n          // maintain x position and iterate y axis from initial position to desiredPosition multiplying by its direction\n          const passedPosition = {\n            x: initialPosition.x,\n            y: initialPosition.y + i * stepY\n          };\n\n          // if any intermediate tile is occupied, then is invalid\n          if (this.tileIsOccupied(passedPosition, boardState)) {\n            return false;\n          }\n        }\n      } else if (dy === 0) {\n        // iterate all positions between actual position and desired position dx\n        for (let i = 1; i < Math.abs(dx); i++) {\n          // maintain y position and iterate x axis from initial position to desiredPosition multiplying by its direction\n          const passedPosition = {\n            x: initialPosition.x + i * stepX,\n            y: initialPosition.y\n          };\n\n          // if any intermediate tile is occupied, then is invalid\n          if (this.tileIsOccupied(passedPosition, boardState)) {\n            return false;\n          }\n        }\n      } else {\n        // if its not vertical nor horizontal movement\n        return false;\n      }\n\n      // return true (if is not occupied by our team) or (is ocuppied by opponent)\n      return !this.tileIsOccupied(desiredPosition, boardState) || this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n    } else if (type === PieceType.QUEEN) {\n      // if vertical movement\n      if (dx === 0) {\n        // iterate all positions between actual position and desired position dy\n        for (let i = 1; i < Math.abs(dy); i++) {\n          // maintain x position and iterate y axis from initial position to desiredPosition multiplying by its direction\n          const passedPosition = {\n            x: initialPosition.x,\n            y: initialPosition.y + i * stepY\n          };\n\n          // if any intermediate tile is occupied, then is invalid\n          if (this.tileIsOccupied(passedPosition, boardState)) {\n            return false;\n          }\n        }\n      } else if (dy === 0) /* if horizontal movement*/{\n          // iterate all positions between actual position and desired position dx\n          for (let i = 1; i < Math.abs(dx); i++) {\n            // maintain y position and iterate x axis from initial position to desiredPosition multiplying by its direction\n            const passedPosition = {\n              x: initialPosition.x + i * stepX,\n              y: initialPosition.y\n            };\n\n            // if any intermediate tile is occupied, then is invalid\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              return false;\n            }\n          }\n        } else if (Math.abs(dx) === Math.abs(dy)) /* if diagonal movement*/{\n          // iterate all positions between actual position and desired position (dx or dy)\n          for (let i = 1; i < Math.abs(dx); i++) {\n            // change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\n            const passedPosition = {\n              x: initialPosition.x + i * stepX,\n              y: initialPosition.y + i * stepY\n            };\n\n            // if any intermediate tile is occupied, then is invalid\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              return false;\n            }\n          }\n        } else /* desired movement is not vertical nor horinzontal nor diagonal*/{\n          return false;\n        }\n\n      // return true (if is not occupied by our team) or (is ocuppied by opponent)\n      return !this.tileIsOccupied(desiredPosition, boardState) || this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n    } else if (type === PieceType.KING) {\n      //one tile movement\n      if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1) {\n        return !this.tileIsOccupied(desiredPosition, boardState) || this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n      }\n    }\n    return false;\n  }\n}","map":{"version":3,"names":["PieceType","TeamType","samePosition","Referee","tileIsOccupied","position","boardState","piece","find","p","tileIsOccupiedByOpponent","team","isEnPassantMove","initialPosition","desiredPosition","type","pawnDirection","OUR","PAWN","y","x","enPassant","pawnMove","dx","dy","specialRow","knightMove","knightX","knightY","i","isValidMove","console","log","stepX","stepY","KNIGHT","BISHOP","Math","abs","passedPosition","ROOK","QUEEN","KING"],"sources":["/home/Outer/Documents/chess-react/src/referee/Referee.ts"],"sourcesContent":["import { PieceType, TeamType, Piece, Position, samePosition} from \"../Constants\";\n\n\nexport default class Referee{\n    tileIsOccupied(position:Position, boardState: Piece[]):boolean{\n        const piece = boardState.find((p) => samePosition(p.position,position));\n        return piece?true:false;\n    }\n\n    tileIsOccupiedByOpponent(position:Position, boardState:Piece[], team:TeamType):boolean{\n        const piece = boardState.find((p)=>samePosition(p.position, position) && p.team!==team);\n        return piece?true:false;\n    }\n\n    isEnPassantMove(initialPosition: Position, desiredPosition:Position, type:PieceType, team:TeamType, boardState:Piece[]):boolean{\n        const pawnDirection = (team === TeamType.OUR)? 1:-1;\n\n        if(type===PieceType.PAWN){\n            if(desiredPosition.y-initialPosition.y===pawnDirection && ((desiredPosition.x-initialPosition.x===-1) || (desiredPosition.x-initialPosition.x===1))){\n                const piece = boardState.find((p)=> p.position.x===desiredPosition.x && (p.position.y===desiredPosition.y - pawnDirection && p.enPassant));\n\n                return piece?true:false;\n            }\n        }\n        return false;\n    }\n\n    pawnMove(initialPosition:Position, desiredPosition: Position, team:TeamType,dx:number, dy:number, boardState:Piece[]):boolean{\n            const specialRow = (team === TeamType.OUR)?1:6;\n            const pawnDirection = (team === TeamType.OUR)? 1:-1;\n\n            if(initialPosition.x===desiredPosition.x && initialPosition.y===specialRow && dy===2*pawnDirection){\n                if(!this.tileIsOccupied(desiredPosition,boardState) && !this.tileIsOccupied({x: desiredPosition.x, y:desiredPosition.y-pawnDirection}, boardState)){\n                    return true;\n                }\n            }else if(initialPosition.x===desiredPosition.x && dy===pawnDirection){\n                    return !this.tileIsOccupied(desiredPosition,boardState)\n            }\n            //attack\n            else if(dy===pawnDirection && ((dx===-1) || (dx===1))){\n                return this.tileIsOccupiedByOpponent(desiredPosition,boardState,team);\n            }\n        return false;\n    }\n\n\n    knightMove(initialPosition:Position, desiredPosition: Position, team:TeamType,dx:number, dy:number, boardState:Piece[]):boolean{\n            // moving mechanics\n            // 8 different tiles possible\n\n            const knightX = [1,2,2,1,-1,-2,-2,-1];\n            const knightY = [2,1,-1,-2,-2,-1,1,2];\n\n            for(let i=0;i<8;i++){\n                if((desiredPosition.x - initialPosition.x === knightX[i]) && (desiredPosition.y - initialPosition.y === knightY[i])){\n                    return (!this.tileIsOccupied(desiredPosition,boardState) || this.tileIsOccupiedByOpponent(desiredPosition,boardState, team))\n                }\n          }\n        return false;\n    }\n\n\n    isValidMove(initialPosition:Position, desiredPosition: Position, type:PieceType, team:TeamType, boardState:Piece[]){\n        console.log(`referee checking.. piece: ${type}`);\n        //movement\n        const dx = desiredPosition.x - initialPosition.x; // difference in X axis\n        const dy = desiredPosition.y - initialPosition.y; // difference in Y axis\n        const stepX = dx > 0 ? 1 : -1; // direction of X axis: 1 or -1\n        const stepY = dy > 0 ? 1 : -1; // direction of Y axis: 1 or -1\n\n        \n\n        if(type === PieceType.PAWN){\n            return this.pawnMove(initialPosition, desiredPosition, team, dx, dy, boardState);\n        } else if(type === PieceType.KNIGHT){\n            return this.knightMove(initialPosition, desiredPosition, team, dx, dy, boardState);\n        } else if (type === PieceType.BISHOP) {\n\n            // diagonal movement implies that difference between axis should be equal\n            if (Math.abs(dx) === Math.abs(dy)) {\n\n                // iterate all positions between actual position and desired position (dx or dy)\n                for (let i = 1; i < Math.abs(dx); i++) {\n                    // change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\n                    const passedPosition: Position = {\n                        x: initialPosition.x + i * stepX,\n                        y: initialPosition.y + i * stepY,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (this.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n\n                // return true (if is not occupied by our team) or (is ocuppied by opponent)\n                return !this.tileIsOccupied(desiredPosition, boardState) ||\n                    this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n            }\n        } else if (type === PieceType.ROOK) {\n\n            // vertical movement\n            if (dx === 0){\n                // iterate all positions between actual position and desired position dy\n                for (let i = 1; i < Math.abs(dy); i++) {\n                    // maintain x position and iterate y axis from initial position to desiredPosition multiplying by its direction\n                    const passedPosition: Position = {\n                        x: initialPosition.x,\n                        y: initialPosition.y + i * stepY,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (this.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n            } else if (dy === 0) {\n                // iterate all positions between actual position and desired position dx\n                for (let i = 1; i < Math.abs(dx); i++) {\n                    // maintain y position and iterate x axis from initial position to desiredPosition multiplying by its direction\n                    const passedPosition: Position = {\n                        x: initialPosition.x + i * stepX,\n                        y: initialPosition.y,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (this.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n            } else{\n                // if its not vertical nor horizontal movement\n                return false;\n            }\n\n            // return true (if is not occupied by our team) or (is ocuppied by opponent)\n            return !this.tileIsOccupied(desiredPosition, boardState) ||\n                this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n\n        } else if (type === PieceType.QUEEN) {\n\n            // if vertical movement\n            if (dx === 0){\n                // iterate all positions between actual position and desired position dy\n                for (let i = 1; i < Math.abs(dy); i++) {\n                    // maintain x position and iterate y axis from initial position to desiredPosition multiplying by its direction\n                    const passedPosition: Position = {\n                        x: initialPosition.x,\n                        y: initialPosition.y + i * stepY,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (this.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n            } else if (dy === 0) /* if horizontal movement*/{\n\n                // iterate all positions between actual position and desired position dx\n                for (let i = 1; i < Math.abs(dx); i++) {\n                    // maintain y position and iterate x axis from initial position to desiredPosition multiplying by its direction\n                    const passedPosition: Position = {\n                        x: initialPosition.x + i * stepX,\n                        y: initialPosition.y,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (this.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n            } else if(Math.abs(dx) === Math.abs(dy)) /* if diagonal movement*/{\n\n                // iterate all positions between actual position and desired position (dx or dy)\n                for (let i = 1; i < Math.abs(dx); i++) {\n                    // change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\n                    const passedPosition: Position = {\n                        x: initialPosition.x + i * stepX,\n                        y: initialPosition.y + i * stepY,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (this.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n            } else /* desired movement is not vertical nor horinzontal nor diagonal*/{\n                return false;\n            }\n\n            // return true (if is not occupied by our team) or (is ocuppied by opponent)\n            return !this.tileIsOccupied(desiredPosition, boardState) ||\n                this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n\n\n        } else if(type === PieceType.KING){\n            //one tile movement\n            if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1){\n                return (!this.tileIsOccupied(desiredPosition, boardState) || this.tileIsOccupiedByOpponent(desiredPosition, boardState, team));\n            }\n        }\n\n        return false;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
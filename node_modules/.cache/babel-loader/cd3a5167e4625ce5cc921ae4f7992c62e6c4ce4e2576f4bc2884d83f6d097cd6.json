{"ast":null,"code":"import { PieceType, TeamType, samePosition } from \"../Constants\";\nexport default class Referee {\n  tileIsOccupied(position, boardState) {\n    const piece = boardState.find(p => samePosition(p.position, position));\n    return piece ? true : false;\n  }\n  tileIsOccupiedByOpponent(position, boardState, team) {\n    const piece = boardState.find(p => samePosition(p.position, position) && p.team !== team);\n    return piece ? true : false;\n  }\n  isEnPassantMove(initialPosition, desiredPosition, type, team, boardState) {\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n    if (type === PieceType.PAWN) {\n      if (desiredPosition.y - initialPosition.y === pawnDirection && (desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1)) {\n        const piece = boardState.find(p => p.position.x === desiredPosition.x && p.position.y === desiredPosition.y - pawnDirection && p.enPassant);\n        return piece ? true : false;\n      }\n    }\n    return false;\n  }\n  pawnMove(initialPosition, desiredPosition, team, dx, dy, boardState) {\n    const specialRow = team === TeamType.OUR ? 1 : 6;\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n    if (initialPosition.x === desiredPosition.x && initialPosition.y === specialRow && dy === 2 * pawnDirection) {\n      if (!this.tileIsOccupied(desiredPosition, boardState) && !this.tileIsOccupied({\n        x: desiredPosition.x,\n        y: desiredPosition.y - pawnDirection\n      }, boardState)) {\n        return true;\n      }\n    } else if (initialPosition.x === desiredPosition.x && dy === pawnDirection) {\n      return !this.tileIsOccupied(desiredPosition, boardState);\n    }\n    //attack\n    else if (dy === pawnDirection && (dx === -1 || dx === 1)) {\n      return this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n    }\n    return false;\n  }\n  knightMove(initialPosition, desiredPosition, team, dx, dy, boardState) {\n    // moving mechanics\n    // 8 different tiles possible\n\n    const knightX = [1, 2, 2, 1, -1, -2, -2, -1];\n    const knightY = [2, 1, -1, -2, -2, -1, 1, 2];\n    for (let i = 0; i < 8; i++) {\n      if (dx === knightX[i] && dy === knightY[i]) {\n        return !this.tileIsOccupied(desiredPosition, boardState) || this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n      }\n    }\n    return false;\n  }\n  bishopMove(initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState) {\n    // diagonal movement implies that difference between axis should be equal\n    if (Math.abs(dx) === Math.abs(dy)) {\n      // iterate all positions between actual position and desired position (dx or dy)\n      for (let i = 1; i < Math.abs(dx); i++) {\n        // change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\n        const passedPosition = {\n          x: initialPosition.x + i * stepX,\n          y: initialPosition.y + i * stepY\n        };\n\n        // if any intermediate tile is occupied, then is invalid\n        if (this.tileIsOccupied(passedPosition, boardState)) {\n          return false;\n        }\n      }\n\n      // return true (if is not occupied by our team) or (is ocuppied by opponent)\n      return !this.tileIsOccupied(desiredPosition, boardState) || this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n    }\n    return false;\n  }\n  rookMove(initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState) {\n    // vertical movement\n    if (dx === 0) {\n      // iterate all positions between actual position and desired position dy\n      for (let i = 1; i < Math.abs(dy); i++) {\n        // maintain x position and iterate y axis from initial position to desiredPosition multiplying by its direction\n        const passedPosition = {\n          x: initialPosition.x,\n          y: initialPosition.y + i * stepY\n        };\n\n        // if any intermediate tile is occupied, then is invalid\n        if (this.tileIsOccupied(passedPosition, boardState)) {\n          return false;\n        }\n      }\n    } // horizontal movement\n    else if (dy === 0) {\n      // iterate all positions between actual position and desired position dx\n      for (let i = 1; i < Math.abs(dx); i++) {\n        // maintain y position and iterate x axis from initial position to desiredPosition multiplying by its direction\n        const passedPosition = {\n          x: initialPosition.x + i * stepX,\n          y: initialPosition.y\n        };\n\n        // if any intermediate tile is occupied, then is invalid\n        if (this.tileIsOccupied(passedPosition, boardState)) {\n          return false;\n        }\n      }\n    } else {\n      // if its not vertical nor horizontal movement\n      return false;\n    }\n    // return true (if is not occupied by our team) or (is ocuppied by opponent)\n    return !this.tileIsOccupied(desiredPosition, boardState) || this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n  }\n  queenMove(initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState) {\n    return this.bishopMove(initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState) || this.rookMove(initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState);\n  }\n  kingMove(initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState) {\n    //one tile movement\n    if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1) {\n      return !this.tileIsOccupied(desiredPosition, boardState) || this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n    }\n    return false;\n  }\n  isValidMove(initialPosition, desiredPosition, type, team, boardState) {\n    console.log(`referee checking.. piece: ${type}`);\n    //movement\n    const dx = desiredPosition.x - initialPosition.x; // difference in X axis\n    const dy = desiredPosition.y - initialPosition.y; // difference in Y axis\n    const stepX = dx > 0 ? 1 : -1; // direction of X axis: 1 or -1\n    const stepY = dy > 0 ? 1 : -1; // direction of Y axis: 1 or -1\n\n    switch (type) {\n      case PieceType.PAWN:\n        {\n          return this.pawnMove(initialPosition, desiredPosition, team, dx, dy, boardState);\n        }\n      case PieceType.KNIGHT:\n        {\n          return this.knightMove(initialPosition, desiredPosition, team, dx, dy, boardState);\n        }\n      case PieceType.BISHOP:\n        {\n          return this.bishopMove(initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState);\n        }\n      case PieceType.ROOK:\n        {\n          return this.rookMove(initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState);\n        }\n      case PieceType.QUEEN:\n        {\n          return this.queenMove(initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState);\n        }\n      case PieceType.KING:\n        {\n          return this.kingMove(initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState);\n        }\n    }\n  }\n}","map":{"version":3,"names":["PieceType","TeamType","samePosition","Referee","tileIsOccupied","position","boardState","piece","find","p","tileIsOccupiedByOpponent","team","isEnPassantMove","initialPosition","desiredPosition","type","pawnDirection","OUR","PAWN","y","x","enPassant","pawnMove","dx","dy","specialRow","knightMove","knightX","knightY","i","bishopMove","stepX","stepY","Math","abs","passedPosition","rookMove","queenMove","kingMove","isValidMove","console","log","KNIGHT","BISHOP","ROOK","QUEEN","KING"],"sources":["/home/Outer/Documents/chess-react/src/referee/Referee.ts"],"sourcesContent":["import { PieceType, TeamType, Piece, Position, samePosition} from \"../Constants\";\n\n\nexport default class Referee{\n    tileIsOccupied(position:Position, boardState: Piece[]):boolean{\n        const piece = boardState.find((p) => samePosition(p.position,position));\n        return piece?true:false;\n    }\n\n    tileIsOccupiedByOpponent(position:Position, boardState:Piece[], team:TeamType):boolean{\n        const piece = boardState.find((p)=>samePosition(p.position, position) && p.team!==team);\n        return piece?true:false;\n    }\n\n    isEnPassantMove(initialPosition: Position, desiredPosition:Position, type:PieceType, team:TeamType, boardState:Piece[]):boolean{\n        const pawnDirection = (team === TeamType.OUR)? 1:-1;\n\n        if(type===PieceType.PAWN){\n            if(desiredPosition.y-initialPosition.y===pawnDirection && ((desiredPosition.x-initialPosition.x===-1) || (desiredPosition.x-initialPosition.x===1))){\n                const piece = boardState.find((p)=> p.position.x===desiredPosition.x && (p.position.y===desiredPosition.y - pawnDirection && p.enPassant));\n\n                return piece?true:false;\n            }\n        }\n        return false;\n    }\n\n    pawnMove(initialPosition:Position, desiredPosition: Position, team:TeamType,dx:number, dy:number, boardState:Piece[]):boolean{\n            const specialRow = (team === TeamType.OUR)?1:6;\n            const pawnDirection = (team === TeamType.OUR)? 1:-1;\n\n            if(initialPosition.x===desiredPosition.x && initialPosition.y===specialRow && dy===2*pawnDirection){\n                if(!this.tileIsOccupied(desiredPosition,boardState) && !this.tileIsOccupied({x: desiredPosition.x, y:desiredPosition.y-pawnDirection}, boardState)){\n                    return true;\n                }\n            }else if(initialPosition.x===desiredPosition.x && dy===pawnDirection){\n                    return !this.tileIsOccupied(desiredPosition,boardState)\n            }\n            //attack\n            else if(dy===pawnDirection && ((dx===-1) || (dx===1))){\n                return this.tileIsOccupiedByOpponent(desiredPosition,boardState,team);\n            }\n        return false;\n    }\n\n\n    knightMove(initialPosition: Position, desiredPosition: Position, team: TeamType, dx: number, dy: number, boardState: Piece[]): boolean {\n        // moving mechanics\n        // 8 different tiles possible\n\n        const knightX = [1, 2, 2, 1, -1, -2, -2, -1];\n        const knightY = [2, 1, -1, -2, -2, -1, 1, 2];\n\n        for (let i = 0; i < 8; i++) {\n            if ((dx === knightX[i]) && (dy === knightY[i])) {\n                return (!this.tileIsOccupied(desiredPosition, boardState) || this.tileIsOccupiedByOpponent(desiredPosition, boardState, team))\n            }\n        }\n        return false;\n    }\n\n    bishopMove(initialPosition:Position, desiredPosition: Position, team:TeamType,dx:number, dy:number, stepX:number, stepY:number, boardState:Piece[]):boolean{\n            // diagonal movement implies that difference between axis should be equal\n            if (Math.abs(dx) === Math.abs(dy)) {\n\n                // iterate all positions between actual position and desired position (dx or dy)\n                for (let i = 1; i < Math.abs(dx); i++) {\n                    // change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\n                    const passedPosition: Position = {\n                        x: initialPosition.x + i * stepX,\n                        y: initialPosition.y + i * stepY,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (this.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n\n                // return true (if is not occupied by our team) or (is ocuppied by opponent)\n                return !this.tileIsOccupied(desiredPosition, boardState) ||\n                    this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n            }\n        return false;\n    }\n\n    rookMove(initialPosition:Position, desiredPosition: Position, team:TeamType,dx:number, dy:number, stepX:number, stepY:number, boardState:Piece[]):boolean{\n            // vertical movement\n            if (dx === 0){\n                // iterate all positions between actual position and desired position dy\n                for (let i = 1; i < Math.abs(dy); i++) {\n                    // maintain x position and iterate y axis from initial position to desiredPosition multiplying by its direction\n                    const passedPosition: Position = {\n                        x: initialPosition.x,\n                        y: initialPosition.y + i * stepY,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (this.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n            } // horizontal movement\n            else if (dy === 0) {\n                // iterate all positions between actual position and desired position dx\n                for (let i = 1; i < Math.abs(dx); i++) {\n                    // maintain y position and iterate x axis from initial position to desiredPosition multiplying by its direction\n                    const passedPosition: Position = {\n                        x: initialPosition.x + i * stepX,\n                        y: initialPosition.y,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (this.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n            } else {\n            // if its not vertical nor horizontal movement\n            return false;\n        }\n                // return true (if is not occupied by our team) or (is ocuppied by opponent)\n                return !this.tileIsOccupied(desiredPosition, boardState) ||\n                    this.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n    }\n\n    queenMove(initialPosition:Position, desiredPosition: Position, team:TeamType,dx:number, dy:number, stepX:number, stepY:number, boardState:Piece[]):boolean{\n        return (this.bishopMove(initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState) || this.rookMove(initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState));\n    }\n\n    kingMove(initialPosition:Position, desiredPosition: Position, team:TeamType,dx:number, dy:number, stepX:number, stepY:number, boardState:Piece[]):boolean{\n            //one tile movement\n            if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1){\n                return (!this.tileIsOccupied(desiredPosition, boardState) || this.tileIsOccupiedByOpponent(desiredPosition, boardState, team));\n            }\n        return false;\n    }\n\n\n    isValidMove(initialPosition:Position, desiredPosition: Position, type:PieceType, team:TeamType, boardState:Piece[]){\n        console.log(`referee checking.. piece: ${type}`);\n        //movement\n        const dx = desiredPosition.x - initialPosition.x; // difference in X axis\n        const dy = desiredPosition.y - initialPosition.y; // difference in Y axis\n        const stepX = dx > 0 ? 1 : -1; // direction of X axis: 1 or -1\n        const stepY = dy > 0 ? 1 : -1; // direction of Y axis: 1 or -1\n\n        switch(type){\n            case PieceType.PAWN:{\n            return this.pawnMove(initialPosition, desiredPosition, team, dx, dy, boardState);\n            }\n            case PieceType.KNIGHT:{\n            return this.knightMove(initialPosition, desiredPosition, team, dx, dy, boardState);\n            }\n            case PieceType.BISHOP:{\n            return this.bishopMove(initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState);\n            }\n            case PieceType.ROOK:{\n            return this.rookMove(initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState);\n            }\n            case PieceType.QUEEN:{\n            return this.queenMove(initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState);\n            }\n            case PieceType.KING:{\n            return this.kingMove(initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState);\n            }\n        }\n\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}